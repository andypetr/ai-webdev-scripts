// constants parsed from the config file (not really constants because it's JS, but you get the idea)var MAX_WIDTH = null;var X_GAP = null;var Y_GAP = null;var ROOT_LAYER = null;var HIT_LAYER = null;var EXPORT_FORMAT = null;var OUTPUT_FILENAME = null;var OUTPUT_FORMAT = null;var OUTPUT_TYPE = null;// variablesvar offsetX = 0; // the horizontal amount to move a graphic (is based on the position of the prior graphic)var offsetY = 0; // the vertical amount to move a graphic (is based on the position of the prior graphic)var count = 0;var aggregateWidth = 0;var aggregateHeight = 0;var lastLeft = 0;var lastTop = 0;var output = []; // contents of output filevar doc; // the active documentvar filePath;var configFile;var parsed = true; // whether config file was parsed correctlyvar errorMsg = "There is a problem in the configuration file. "; // error message if something goes wrong with reading config filevar readConfig; // holds reference to the configuration file// if there are graphics on the artboardif ( app.documents.length > 0 ) {    doc = app.activeDocument;    filePath = doc.path+"/config.yml";    configFile = new File(filePath);// if config file is not found, abortif (configFile.open('r') == false) { alert( "Configuration file config.txt not found! Check that this file exists in the same directory as the script." ) };else{        // read the config file and parse out values    readConfig = configFile.read();    MAX_WIDTH = parseConfig( "max_width" , Number );    X_GAP = parseConfig( "x_gap" , Number );    Y_GAP = parseConfig( "y_gap" , Number );    ROOT_LAYER = parseConfig( "root_layer_prefix" );    HIT_LAYER = parseConfig( "hit_layer_prefix" );    EXPORT_FORMAT = parseConfig( "export_format" );    OUTPUT_FILENAME = parseConfig( "output_filename" );    OUTPUT_FORMAT = parseConfig( "output_format" );    OUTPUT_TYPE = parseConfig( "output_type" );    // TODO validation of output_format in regard to output_type    // if it wasn't parsed, abort    if (!parsed) { alert( errorMsg ) };    else    {            if (doc.layers.length > 0)            {               moveLayer( doc , X_GAP , Y_GAP , 0 );            }            // fit artboard to artwork and deselect artwork            doc.fitArtboardToSelectedArt(0);            // deselect items            for (var p = 0; p < doc.pageItems.length; p++)            {                doc.pageItems[p].selected = false;            }            writeTextOutput();            writeCSSOutput();        }    }}// regex parse config file// value = value to search for in config file// type = type to cast tofunction parseConfig( value , type ){    var reg = value + "[ ]*:[ ]*(.*)";    var pattern = new RegExp(reg);    var result = pattern.exec(readConfig);    var returnVal;    if (!result) { parsed = false; errorMsg += (" Check near '"+value+"'.") }    else    {        returnVal = result[1];        if (type) returnVal = type(returnVal);    }    if (returnVal == '' || returnVal == null || (type == Number && isNaN(returnVal) ) ) { parsed = false; errorMsg += (" Check value of '"+value+"'.")}        return returnVal;}// move the graphics on each layerfunction moveLayer( layer, x , y , level){    var inLayer = layer;        if (layer.typename == "Layer")    {        for (var e = 0; e < layer.pageItems.length; e++)        {            var pathArt = layer.pageItems[e];                        if (level == 1)            {                lastLeft = pathArt.left;                lastTop = pathArt.top;                pathArt.left = 0;                pathArt.top = 0;                if (aggregateWidth+offsetX > MAX_WIDTH)                {                    offsetY-=pathArt.height+Y_GAP;                    offsetX = 0;                    aggregateHeight += offsetY;                }                aggregateWidth += offsetX;                offsetX+=pathArt.width+X_GAP;            }            else if (level > 1)            {                 pathArt.left -= lastLeft;                 pathArt.top -= lastTop;            }                        pathArt.translate(offsetX,offsetY);            pathArt.selected = true;            //$.writeln( "\telm: " +pathArt.name +" | "+ pathArt.width );        }            // if current layer is the root layer, record position        if (layer.name.substring(0,ROOT_LAYER.length) == ROOT_LAYER)        {          output.push({"name":layer.name,"x":pathArt.left,"y":pathArt.top});         }    }        for (var l = 0; l < layer.layers.length; l++)    {              moveLayer( layer.layers[l] , X_GAP , Y_GAP , level+1 );    }}// write text output filefunction writeTextOutput(){    var filePath = doc.path+"/"+OUTPUT_FILE+"."+OUTPUT_TYPE;     var outputFile =new File(filePath);     var finalOutput = "";       outputFile.open('w');              for (var i = 0; i < output.length; i++)       {            var format = OUTPUT_FORMAT;            var name =  output[i]["name"];            var x = output[i]["x"];            var y = output[i]["y"];                         var search = ROOT_LAYER;            var regex = new RegExp(search, 'g');            format = format.replace(regex, name);            search = (name+"x_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, x);            search = (name+"y_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, y);                        if (OUTPUT_TYPE == "json" && i != output.length-1) format += ",";                        finalOutput += "\t"+format+"\n";       }        if (OUTPUT_TYPE == "json") finalOutput = "{\n"+finalOutput+"}";       outputFile.write( finalOutput );       outputFile.close();}/ write CSS output filefunction writeCSSOutput(){    var filePath = doc.path+"/"+OUTPUT_FILENAME+".css";    var outputFile =new File(filePath);     var finalOutput = "";       outputFile.open('w');              for (var i = 0; i < output.length; i++)       {            var format = OUTPUT_FORMAT;            var name =  output[i]["name"];            var x = output[i]["x"];            var y = output[i]["y"];                         var search = ROOT_LAYER;            var regex = new RegExp(search, 'g');            format = format.replace(regex, name);            search = (name+"x_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, x);            search = (name+"y_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, y);                        if (OUTPUT_TYPE == "json" && i != output.length-1) format += ",";                        finalOutput += "\t"+format+"\n";       }        if (OUTPUT_TYPE == "json") finalOutput = "{\n"+finalOutput+"}";       outputFile.write( finalOutput );       outputFile.close();}