/* by Anselm Bradford http://twitter.com/anselmbradford */// constants parsed from the config file (not really constants because it's JS, but you get the idea)var MAX_WIDTH = null;var X_GAP = null;var Y_GAP = null;var ROOT_LAYER = null;var AREA_LAYER = null;var HIT_LAYER = null;var EXPORT_FORMAT = null;var JPG_QUALITY = null;var OUTPUT_FILENAME = null;var PARAM_FORMAT = null;var PARAM_TYPE = null;// variablesvar offsetX = 0; // the horizontal amount to move a graphic (is based on the position of the prior graphic)var offsetY = 0; // the vertical amount to move a graphic (is based on the position of the prior graphic)var count = 0;var tallest = 0;var lastLeft = 0;var lastTop = 0;var output = []; // contents of output filevar doc; // the active documentvar folderPath;var filePath;var configFile;var parsed = true; // whether config file was parsed correctlyvar errorMsg = "There is a problem in the configuration file. "; // error message if something goes wrong with reading config filevar readConfig; // holds reference to the configuration file// if there are graphics on the artboardif ( app.documents.length > 0 ) {    doc = app.activeDocument;    filePath = doc.path+"/ai-spritesheet-factory-config.yml";    configFile = new File(filePath);// if config file is not found, create default configif (configFile.open('r') == false) createDefaultConfig();    configFile.open('r');        // read the config file and parse out values    readConfig = configFile.read();    MAX_WIDTH = parseConfig( "max_width" , Number );    X_GAP = parseConfig( "x_gap" , Number );    Y_GAP = parseConfig( "y_gap" , Number );    ROOT_LAYER = parseConfig( "root_layer_prefix" );    AREA_LAYER = parseConfig( "area_layer_prefix" );    HIT_LAYER = parseConfig( "hit_layer_prefix" );    EXPORT_FORMAT = parseConfig( "export_format" );    JPG_QUALITY = parseConfig( "jpg_quality" , Number );    OUTPUT_FILENAME = parseConfig( "output_filename" );    PARAM_FORMAT = parseConfig( "param_format" );    PARAM_TYPE = parseConfig( "param_type" );        GENERATE_HTML = convertStringToBoolean( parseConfig( "generate_html" ) );    GENERATE_CSS = convertStringToBoolean( parseConfig( "generate_css" ) );    GENERATE_PARAM = convertStringToBoolean( parseConfig( "generate_param" ) );    // TODO validation of output_format in regard to output_type    // if it wasn't parsed, abort    if (!parsed) { alert( errorMsg ) };    else    {            if (checkLayerHierarchy())            {               moveLayer( doc , 0 );               recordPosition( doc );                                if (output.length > 1)                {                    // fit artboard to artwork and deselect artwork                    doc.fitArtboardToSelectedArt(0);                    // create build directory                    folderPath = new Folder(doc.path+"/build");                    folderPath.create();                                // export spritesheet in format specified in the config file                    if (EXPORT_FORMAT == "png24") exportPNG24();                    else if (EXPORT_FORMAT == "png8") exportPNG8();                    else if (EXPORT_FORMAT == "gif") exportGIF();                    else if (EXPORT_FORMAT == "jpg") exportJPEG();                                // write css, html, and parameters                    if (GENERATE_CSS) writeCSS();                    if (GENERATE_HTML) writeHTML();                    if (GENERATE_PARAM) writeParameters();                     // undo changes done to file                    app.undo();                                    }                else                {                    // error occurred, undo changes done to file                    app.undo();                    app.redo(); // need this for some reason as the undo seems to go one step too far!                    errorMsg = "Sprite export failed! There are one or less sprites. Check that sprite layers have same prefixes as config file!";                    alert( errorMsg );                }            }            else            {                    // error occurred, undo changes done to file                    app.undo();                    app.redo(); // need this for some reason as the undo seems to go one step too far!                    errorMsg = "Sprite export failed! There is a problem with the layers in this Illustrator file! Check that sprite layers have same prefixes as config file!";                    alert( errorMsg );            }        }    }// convert string to boolean, sadly we can't do this with typecasting with Boolean in parseConfigfunction convertStringToBoolean( value ){    if (value == "true") value = true;    else value = false;    return value;}// regex parse config file// value = value to search for in config file// type = type to cast tofunction parseConfig( value , type ){    var reg = value + "[ ]*:[ ]*(.*)";    var pattern = new RegExp(reg);    var result = pattern.exec(readConfig);    var returnVal;    if (!result) { parsed = false; errorMsg += (" Check near '"+value+"'.") }    else    {        returnVal = result[1];        if (type) returnVal = type(returnVal);    }    if (returnVal == '' || returnVal == null || (type == Number && isNaN(returnVal) ) ) { parsed = false; errorMsg += (" Check value of '"+value+"'.")}        return returnVal;}// check that the sprites are one level infunction checkLayerHierarchy(){        var returnVal = false;    if (doc.layers.length > 0)    {                for (var l = 0; l < doc.layers.length; l++)        {            var layer = doc.layers[l];            if (layer.name.substring(0,ROOT_LAYER.length) == ROOT_LAYER)            {                for (var a = 0; a < layer.pageItems.length; a++)                {                    if (layer.pageItems[a].name.substring(0,AREA_LAYER.length) == AREA_LAYER)                    {                        returnVal = true;                    }                }            }            else            {                    layer.visible = false;            }        }    }    return returnVal;}// move the graphics on each layerfunction moveLayer( layer, level){        if (layer.typename == "Layer")    {        var pathArt;        var numPageItems = layer.pageItems.length;                // bring area layers to front        for (var e = 0; e < numPageItems; e++)        {            pathArt = layer.pageItems[e];            if ( pathArt.name.substring(0,AREA_LAYER.length) == AREA_LAYER && level == 1 )            {                pathArt.zOrder( ZOrderMethod.BRINGTOFRONT );                                if ( lastLeft+pathArt.width+X_GAP > MAX_WIDTH )                {                        lastLeft = 0;                        lastTop -= tallest+Y_GAP;                        tallest = 0;                }                            offsetX = lastLeft-pathArt.left;                offsetY = lastTop-pathArt.top;                                    pathArt.left = lastLeft;                pathArt.top = lastTop;                                  lastLeft = pathArt.left+pathArt.width+X_GAP;                lastTop = pathArt.top;                                tallest = Math.max(tallest, pathArt.height);            }        }            for (e = 0; e < numPageItems; e++)        {            pathArt = layer.pageItems[e];                        if ( !(pathArt.name.substring(0,AREA_LAYER.length) == AREA_LAYER && level == 1) )            {                pathArt.translate(offsetX,offsetY);            }         }    }        for (var l = 0; l < layer.layers.length; l++)    {              moveLayer( layer.layers[l] , level+1 );    }}// record the positions of the graphics on each layerfunction recordPosition( layer ){    if (layer.typename == "Layer" && layer.visible == true)    {        for (var e = 0; e < layer.pageItems.length; e++)        {            var pathArt = layer.pageItems[e];                        // if current layer is the root layer, record position            if (pathArt.name.substring(0,AREA_LAYER.length) == AREA_LAYER)            {                pathArt.opacity = 0;                var x = pathArt.left;                var y = pathArt.top;                                var width = pathArt.width;                var height = pathArt.height;                                var hitAreaX = pathArt.left;                var hitAreaY = pathArt.top;                var hitAreaWidth = pathArt.width;                var hitAreaHeight = pathArt.height;                                    for (var p = 0; p < layer.pageItems.length; p++)                    {                        var currPathArt = layer.pageItems[p];                        if (currPathArt.name.substring(0,HIT_LAYER.length) == HIT_LAYER)                        {                            // find hit area or report error                               currPathArt.opacity = 0;                               hitAreaX = currPathArt.left;                               hitAreaY = currPathArt.top;                               hitAreaWidth = currPathArt.width;                               hitAreaHeight = currPathArt.height;                                             }                    }                hitAreaY *= -1;                              output.push({"name":layer.name,"x":x,"y":y,"width":width,"height":height,"hitX":hitAreaX,"hitY":hitAreaY,"hitWidth":hitAreaWidth,"hitHeight":hitAreaHeight});            }                        pathArt.selected = true;         }    }        for (var l = 0; l < layer.layers.length; l++)    {              recordPosition( layer.layers[l] );    }}// export a png24 filefunction exportPNG24() {        var exportOptions = new ExportOptionsPNG24();        var type = ExportType.PNG24;        var filePath = folderPath+"/"+OUTPUT_FILENAME+".png";        var fileSpec = new File(filePath);        exportOptions.transparency = true;        doc.exportFile( fileSpec, type, exportOptions );}// export a png8 filefunction exportPNG8() {        var exportOptions = new ExportOptionsPNG8();        var type = ExportType.PNG8;        var filePath = folderPath+"/"+OUTPUT_FILENAME+".png";        var fileSpec = new File(filePath);        exportOptions.transparency = true;        doc.exportFile( fileSpec, type, exportOptions );}// export a giffunction exportGIF() {        var exportOptions = new ExportOptionsGIF();        var type = ExportType.GIF;        var filePath = folderPath+"/"+OUTPUT_FILENAME+".png";        var fileSpec = new File(filePath);        doc.exportFile( fileSpec, type, exportOptions );}// export a jpgfunction exportJPEG() {        var exportOptions = new ExportOptionsJPEG();        var type = ExportType.JPEG;        var filePath = folderPath+"/"+OUTPUT_FILENAME+".png";        var fileSpec = new File(filePath);        exportOptions.optimization = true; // optimized for web viewing        exportOptions.qualitySetting = JPG_QUALITY;        doc.exportFile( fileSpec, type, exportOptions );}// write CSS output filefunction writeCSS(){    var filePath = folderPath+"/"+OUTPUT_FILENAME+".css";    var outputFile =new File(filePath);     var finalOutput = "";       outputFile.open('w');        var filesuffix = EXPORT_FORMAT;    if (EXPORT_FORMAT == "png24" || EXPORT_FORMAT == "png8") filesuffix = "png";              var css = "";       for (var i = 0; i < output.length; i++)       {            var name =  output[i]["name"];            var x = output[i]["x"];            var y = output[i]["y"];             var width = output[i]["width"];            var height = output[i]["height"];             var hitX = output[i]["hitX"];            var hitY = output[i]["hitY"];            var hitWidth = output[i]["hitWidth"];            var hitHeight = output[i]["hitHeight"];                            css += "."+name+"\n{\n";                css += "\tbackground: transparent url('"+OUTPUT_FILENAME+"."+filesuffix+"') no-repeat "+(x*-1)+"px "+y+"px;\n";                css += "\twidth: "+width+"px;\n";                css += "\theight: "+height+"px;\n";                css += "}\r\r";       }          outputFile.write( css );       outputFile.close();}// write html output filefunction writeHTML(){    var filePath = folderPath+"/"+OUTPUT_FILENAME+".html";     var outputFile =new File(filePath);     var finalOutput = "";       outputFile.open('w');                   var name1 =  output[0]["name"];            var name2 =  output[1]["name"];            var x = output[1]["x"];            var y = output[1]["y"];            var width = output[1]["width"];            var height = output[1]["height"];                        var hitX1 = output[0]["hitX"];            var hitY1 = output[0]["hitY"];            var hitWidth1 = output[0]["hitWidth"];            var hitHeight1 = output[0]["hitHeight"];            var hitX2 = output[1]["hitX"];            var hitY2 = output[1]["hitY"];            var hitWidth2 = output[1]["hitWidth"];            var hitHeight2 = output[1]["hitHeight"];                        var js = "var sprite=document.getElementById('sprite-demo');";               js += "var hitArea=document.getElementById('hit-area');";               js += "sprite.classList.remove('"+name1+"');";                js += "sprite.classList.add('"+name2+"');";                js += "sprite.style.width='"+width+"px';";               js += "sprite.style.height='"+height+"px';";               js += "hitArea.style.left='"+(hitX2+(x*-1))+"px';";               js += "hitArea.style.top='"+(hitY2+(y*-1))+"px';";               js += "hitArea.style.width='"+hitWidth2+"px';";               js += "hitArea.style.height='"+hitHeight2+"px';";                                          var css = "left:"+hitX1+"px; top:"+hitY1+"px; width:"+hitWidth1+"px; height:"+hitHeight1+"px; position:absolute; outline:1px solid red;";                        var html = "<!doctype html>\n";                  html += "<html>";                  html += "<head>"                  html += "<title>AI Spritesheet Factory Test</title>";                  html += "<link href='"+OUTPUT_FILENAME+".css' rel='stylesheet' >";                  html += "</head>";                  html += "<body>";                  html += "<h1>Click the red outlined hit area to test transition </h1><p>(<strong>Note</strong>: only works for transition from 1<sup>st</sup> to 2<sup>nd</sup> sprite. Sprites also need to be at least two wide on sheet)</p>";                  html += "<div id='sprite-demo' class='"+name1+"' style='position:relative;'><div id='hit-area' onClick=\""+js+"\" style=\""+css+"\"></div></div>";                  html += "<p><a href='https://github.com/anselmbradford/ai-spritesheet-factory'>Go to Github Repository...</a></p>";                  html += "</div>";                  html += "</body>";                  html += "</html>";                               outputFile.write( html );       outputFile.close();}// write the parameter output filefunction writeParameters(){    var filePath = folderPath+"/"+OUTPUT_FILENAME+"."+PARAM_TYPE;     var outputFile =new File(filePath);     var finalOutput = "";       outputFile.open('w');                    for (var i = 0; i < output.length; i++)       {            var format = PARAM_FORMAT;            var name =  output[i]["name"];            var x = output[i]["x"];            var y = output[i]["y"];             var width = output[i]["width"];            var height = output[i]["height"];             var hitX = output[i]["hitX"];            var hitY = output[i]["hitY"];            var hitWidth = output[i]["hitWidth"];            var hitHeight = output[i]["hitHeight"];                        var search = ROOT_LAYER;            var regex = new RegExp(search, 'g');            format = format.replace(regex, name);                        search = (name+"x_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, x);                        search = (name+"y_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, y);                        search = (name+"width_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, width);                        search = (name+"height_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, height);                        search = (name+"hit_x_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, hitX);                        search = (name+"hit_y_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, hitY);            search = (name+"hit_width_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, hitWidth);            search = (name+"hit_height_value");            regex = new RegExp(search, 'g');            format = format.replace(regex, hitHeight);                        // remove extraneous sprite names            search = name;            regex = new RegExp(search, 'g');            format = format.replace(regex, "");            // add back first sprite name            if (PARAM_TYPE == "json")             {                format = format.substring(2,format.length);                format = '"'+name+'"'+format;                if ( i != output.length-1) format += ",";            }                                finalOutput += "\t"+format+"\n";       }        if (PARAM_TYPE == "json") finalOutput = "{\n"+finalOutput+"}";       outputFile.write( finalOutput );       outputFile.close();}function createDefaultConfig(){    var contents = '# Maximum width of the sprite sheet\n';       contents += 'max_width : 500\n\r';       contents += '# Horizontal gap between sprites\n';       contents += 'x_gap : 24\n\r';       contents += '# Vertical gap between sprites\n';       contents += 'y_gap : 24\n\r';       contents += '# root layer name to use as sprite area\n';       contents += 'root_layer_prefix : sprite_\n\r';       contents += '# layer name of layout area\n';       contents += 'area_layer_prefix : area_\n\r';       contents += '# layer name of hit area\n';       contents += 'hit_layer_prefix : hit_\n\r';       contents += '# export filetype (accepts "png24", "png8", or "jpg")\n';       contents += 'export_format : png24\n\r';       contents += '# quality of jpg export (accepts 0-100)\n';       contents += 'jpg_quality : 30\n\r';       contents += '# output file name\n';       contents += 'output_filename : sprites\n\r';       contents += '# whether to generate HTML (accepts "true" or "false")\n';       contents += 'generate_html : true\n\r';       contents += '# whether to generate CSS (accepts "true" or "false")\n';       contents += 'generate_css : true\n\r';       contents += '# whether to generate parameters (accepts "true" or "false")\n';       contents += 'generate_param : true\n\r';       contents += '# output format. This is a single entry in the output file script. Script will search for prefixes (from above)';       contents += 'and inject full layer name and associated value\n';       contents += '# prefixes here MUST match above sprite and hit area layer prefixes!\n';       contents += 'param_format : "sprite_":{"sprite_x":"sprite_x_value","sprite_y":"sprite_y_value","sprite_width":"sprite_width_value","sprite_height":"sprite_height_value",';       contents += '"sprite_hit_x":"sprite_hit_x_value","sprite_hit_y":"sprite_hit_y_value","sprite_hit_width":"sprite_hit_width_value","sprite_hit_height":"sprite_hit_height_value"}\n\r';       contents += '# type of parameter data (accepts "json") # TODO add "xml", "array"\n';       contents += 'param_type : json\n';        var outputFile =new File(filePath);           outputFile.open('w');          outputFile.write(contents);          outputFile.close();}